; Based on the hgs-pickup program. This includes an extra step as a demonstration
; of an EDA's ability to chain multiple operations together to produce a solution
; to a problem. In this case, it's creating a screwdriver in order to remove a 
; screw. In POODL, the solution should look like this:
;   (unscrew "screw" WITH "toothbrush" UNTIL "removed" [
;       (whittle "toothbrush" WITH "knife" UNTIL "screwdriver-shaped" [])
;   ])
;
; The POODL prompt for this would be (where "BLANK" refers to steps or objects
; the agent may fill in):
;   (unscrew "screw" WITH "BLANK" UNTIL "removed" [BLANK])

; Set up the objects and ontologies
screw:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
toothbrush:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
knife:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
state:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
s:(ent 1) [[SYNC_ONCE now 1 forever root nil]] ; A screw
t:(ent 1) [[SYNC_ONCE now 1 forever root nil]] ; A toothbrush
k:(ent 1) [[SYNC_ONCE now 1 forever root nil]] ; A knife

; Set some facts about the objects
s_is_a_screw:(mk.val s essence screw 1) |[]
(fact s_is_a_screw 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]
t_is_a_toothbrush:(mk.val t essence toothbrush 1) |[]
(fact t_is_a_toothbrush 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]
k_is_a_knife:(mk.val k essence knife 1) |[]
(fact k_is_a_knife 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

; Set up some antifacts
s_is_a_toothbrush:(mk.val s essence toothbrush 1) |[]
(|fact s_is_a_toothbrush 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]

; Set up the emulator state and inject it
; emulator_state: [Is the screw unscrewed?, Is the toothbrush shaped like a screwdriver?]
e1:(ent 1) [[SYNC_ONCE now 1 forever root nil]]
emulator_state:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
emulator:(std_grp 2 0 0 0 []) [[SYNC_ONCE now 0 forever root nil COV_OFF 0]]

; This program runs in the primary group to re-inject any (fact (goal (fact (cmd ::)))) into emulator.
pgm_inject_in_emulator_group:(pgm [] []
   (ptn f_G:(fact G:(goal (fact (cmd ::) ::) ::) ::) [])
[]
   ; Only re-inject non-simulation goals.
   (= (is_sim G) false)
[]
   (inj [f_G [SYNC_ONCE (now) 1 1 emulator nil]])
1) |[]
(ipgm pgm_inject_in_emulator_group [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]


; Models and CSTs
; M0: If we use a screwdriver-shaped thing on a screw, it will become unscrewed
; M1: If we have a screw and a screwdriver-shaped thing, we can use M0
; S0: I have a screw and screwdriver-shaped thing
; M2: If we whittle a toothbrush with a knife, it will be screwdriver-shaped
; M3: If we have a knife and a toothbrush (that is not screwdriver-shaped), we can use M2
; S1: I have a knife and a toothbrush

; S0: I have a screw and screwdriver-shaped thing
S0:(cst [] []
   (fact (mk.val S: essence screw :) T0: T1: : :)              ; There exists a screw
   (fact (mk.val S: state "screwed in" :) T0: T1: : :)         ; that is not yet unscrewed
   (fact (mk.val T: essence toothbrush :) T0: T1: : :)         ; and a toothbrush
   (fact (mk.val T: state "screwdriver-shaped" :) T0: T1: : :) ; that is screwdriver-shaped
   ; (|fact (mk.val S: essence toothbrush :) T0: T1: : :) ; that is screwdriver-shaped
|[]
|[]
[stdin] 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; S1: I have a knife and a toothbrush
S1:(cst [] []
   (fact (mk.val K: essence knife :) T0: T1: : :)               ; There exists a knife
   (fact (mk.val T: essence toothbrush :) T0: T1: : :)          ; and a toothbrush
   (fact (mk.val T: state "toothbrush" :) T0: T1: : :) ; that is not yet screwdriver-shaped
|[]
|[]
[stdin] 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; === Set up the models ===
; M0: If we use a screwdriver-shaped thing on a screw, it will become unscrewed
M0:(mdl [T: S: (ti T0: T1:)] []
   (fact (cmd use_tool [T: S:] :) T2: T1_cmd: : :)
   (fact (mk.val S: state "unscrewed" 1) T1_RHS: T3: : :)
[]
   T1_RHS:(+ T0 100ms)
   T3:(+ T1 100ms)
[]
   T2:(- T1_RHS 80ms); Change 50ms delay to 20ms.
   T1_cmd:(- T3 100ms)
   T0:(- T1_RHS 100ms)
   T1:(- T3 100ms)
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]


; M1: If we have a screw and a screwdriver-shaped thing, we can use M0
M1:(mdl [] []
   (fact (icst S0 [] [T: S:] : :) T0: T1: : :)
   (fact (imdl M0 [T: S: (ti T0: T1:)] [T1_RHS: T3:] : :) T0: T1: : :)
|[]
|[]
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; M2: If we whittle a toothbrush with a knife, it will be screwdriver-shaped
M2:(mdl [K: T: (ti T0: T1:)] []
   (fact (cmd use_tool [K: T:] :) T2: T1_cmd: : :)
   (fact (mk.val T: state "screwdriver-shaped" 1) T1_RHS: T3: : :)
[]
   T1_RHS:(+ T0 100ms)
   T3:(+ T1 100ms)
[]
   T2:(- T1_RHS 80ms); Change 50ms delay to 20ms.
   T1_cmd:(- T3 100ms)
   T0:(- T1_RHS 100ms)
   T1:(- T3 100ms)
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]


; M3: If we have a knife and a toothbrush (that is not screwdriver-shaped), we can use M2
M3:(mdl [] []
   (fact (icst S1 [] [K: T:] : :) T0: T1: : :)
   (fact (imdl M2 [K: T: (ti T0: T1:)] [T1_RHS: T3:] : :) T0: T1: : :)
|[]
|[]
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]


; === Setup and Drive Maintenance ===
!def DRIVE_START 300ms
start:(pgm [] [] [] []
   (inj [State:(mk.val e1 emulator_state [false false] 1) []])
   (inj []
      (fact State After:(now) (+ After sampling_period) 1 1)
      [SYNC_PERIODIC now 1 1 emulator nil]
   )
1) |[]
(ipgm start [] RUN_ONCE sampling_period VOLATILE NOTIFY 1) [[SYNC_ONCE now 0 forever stdin nil 1]]

m_drive:(mdl [] []
   ; The goal target timings are the same as the drive timings.
   ; (fact (mk.val t state "screwdriver-shaped" 1) T0: T1: 1 1)
   (fact (mk.val s state "unscrewed" 1) T0: T1: 1 1)
   (fact run T0: T1: ::)
|[]
|[]
[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]

pgm_inject_drive:(pgm [] []
   ; This fact repeats periodically. We use it as a "heartbeat".
   (ptn (fact (mk.val s essence screw :) After: Before: ::) [])
[]
   (>= After (+ this.vw.ijt DRIVE_START))
[]
   ; The end of the time interval will be used in m_drive as the end of the goal interval.
   (inj [f_run:(fact run After (+ Before 500ms) 1 1) []])
   (inj [G:(goal f_run self nil 1) []])
   (inj []
      ; Delay a little to allow predictions for this sampling period before injecting the drive.
      (fact G T0:(+ After 10ms) T0 1 1)
      [SYNC_ONCE T0 1 forever primary nil]
   )
   (prb [1 "print" "injected drive" []])
1) |[]
(ipgm pgm_inject_drive [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]

; Before DRIVE_START, just re-inject the same values.
pgm_before_drive:(pgm [] []
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (< After (+ this.vw.ijt DRIVE_START))
[]
   ; All state variables keep the same value.
   (inj [Next_state:(mk.val e1 emulator_state [Unscrewed Shaped] 1) []])
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
   )
1) |[]
(ipgm pgm_before_drive [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]


; === Emulator Interaction ===
; Unscrew something with a screwdriver-shaped object
pgm_cmd_unscrew:(pgm [] []
   (ptn (fact G:(goal (fact Command:(cmd use_tool [t s] ::) Cmd_after: Cmd_before: ::) ::) ::) [])
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= (is_sim G) false)
   (= Unscrewed false)
   (= Shaped true)
   (< Cmd_after Before)
   (> Cmd_before After)
[]
   ; Inject the fact that the command was executed.
   (inj []
      (fact Command (+ After 20ms) Before 1 1)
      [SYNC_ONCE After 1 1 stdin nil]
   )
   ; The screw is now unscrewed
   (inj [Next_state:(mk.val e1 emulator_state [true true] 1) []])
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
   )
   (prb [1 "print" "pgm_cmd_unscrew from command:" [Command]])
1) |[]
(ipgm pgm_cmd_unscrew [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]


; Whittle a toothbrush down to a screwdriver-shaped object
pgm_cmd_whittle:(pgm [] []
   (ptn (fact G:(goal (fact Command:(cmd use_tool [k t] ::) Cmd_after: Cmd_before: ::) ::) ::) [])
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= (is_sim G) false)
   (= Shaped false)
   (< Cmd_after Before)
   (> Cmd_before After)
[]
   ; Inject the fact that the command was executed.
   (inj []
      (fact Command (+ After 20ms) Before 1 1)
      [SYNC_ONCE After 1 1 stdin nil]
   )
   ; The toothbrush is now screwdriver-shaped
   (inj [Next_state:(mk.val e1 emulator_state [Unscrewed true] 1) []])
   (inj []
      (fact Next_state (+ After sampling_period) (+ Before sampling_period) 1 1)
      [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
   )
   (prb [1 "print" "pgm_cmd_whittle from command:" [Command]])
1) |[]
(ipgm pgm_cmd_whittle [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]


; === Inject emulator states ===
; Reinject that the screw is still screwed in (if that's the case)
pgm_inject_mk_vals_screwedin:(pgm [] []
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= Unscrewed false)
[]
   (inj [Val_state:(mk.val s state "screwed in" 1) []])
   (inj []
      (fact Val_state After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
   (prb [1 "print" "s is screwed in" []])
1) |[]
(ipgm pgm_inject_mk_vals_screwedin [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

; Reinject that the screw is unscrewed (if that's the case)
pgm_inject_mk_vals_unscrewed:(pgm [] []
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= Unscrewed true)
[]
   (inj [Val_state:(mk.val s state "unscrewed" 1) []])
   (inj []
      (fact Val_state After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
   (prb [1 "print" "s is unscrewed" []])
1) |[]
(ipgm pgm_inject_mk_vals_unscrewed [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

; Reinject that the toothbrush is not screwdriver-shaoed (if that's the case)
pgm_inject_mk_vals_no_screwdriver:(pgm [] []
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= Shaped false)
[]
   (inj [Val_state:(mk.val t state "toothbrush" 1) []])
   (inj []
      (fact Val_state After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
   (prb [1 "print" "t is not screwdriver-shaped" []])
1) |[]
(ipgm pgm_inject_mk_vals_no_screwdriver [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]

; Reinject that the toothbrush is screwdriver-shaoed (if that's the case)
pgm_inject_mk_vals_screwdriver:(pgm [] []
   (ptn (fact (mk.val e1 emulator_state [Unscrewed: Shaped:] :) After: Before: ::) [])
[]
   (= Shaped true)
[]
   (inj [Val_state:(mk.val t state "screwdriver-shaped" 1) []])
   (inj []
      (fact Val_state After Before 1 1)
      [SYNC_PERIODIC After 1 1 stdin nil]
   )
   (prb [1 "print" "t is screwdriver-shaped" []])
1) |[]
(ipgm pgm_inject_mk_vals_screwdriver [] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever emulator nil 1]
