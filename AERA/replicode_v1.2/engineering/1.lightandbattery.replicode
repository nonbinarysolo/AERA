!dfn (connect :); connect stuff

; Create a few categories
lights:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
batteries:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
connectedto:(ont 1) [[SYNC_ONCE now 0 forever root nil]]
state:(ont 1) [[SYNC_ONCE now 0 forever root nil]]

; Create some objects
light:(ent 1) [[SYNC_ONCE now 0 forever root nil]]
battery:(ent 1) [[SYNC_ONCE now 0 forever root nil]]

; Establish the entities
light_is_a_light:(mk.val light essence lights 1) |[]
battery_is_a_battery:(mk.val battery essence batteries 1) |[]

f_light_is_a_light:(fact light_is_a_light 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]
f_battery_is_a_battery:(fact battery_is_a_battery 0s:0ms:0us GIGASEC 1 1) [[SYNC_AXIOM now 1 forever stdin nil]]


; Two object are connected to each other
is_connected:(cst |[]
[]
   (fact (mk.val A: connectedto B: :) T0: T1: : :)
   (fact (mk.val B: connectedto A: :) T0: T1: : :)
|[]
|[]
[stdin] 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; When two things are connected, they share the is_connected CST
M0:(mdl [A: B:]
[]
   (fact (mk.val A: connectedto B: :) T0: T1: : :)
   (fact (mk.val B: connectedto A: :) T0: T1: : :)
   (fact (icst is_connected |[] [A: B:] : :) : : : : )
|[]
|[]
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; When light is connected to battery, it emits light
M1:(mdl [A: B:]
[]
   (fact (mk.val A: essence lights :) : : : :)
   (fact (mk.val B: essence batteries :) : : : :)
   (fact (icst is_connected |[] [A: B:] : :) : : : : )
   (fact (mk.val A: state "on" :) : : : :)
|[]
|[]
[stdin] 1 1 1 1 1) [[SYNC_ONCE now 0 forever primary nil 1]]

; Goal is to get light
m_drive:(mdl |[]
[]
   (fact (mk.val A: state "on" :) : : 1 1)
   (fact run : : ::)
|[]
|[]
[stdin drives] 1 1 1 0 1) [[SYNC_ONCE now 0 forever primary nil 1]]


; Borrowed from hand-grab-sphere
pgm_inject_drive:(pgm |[]
[]
   ; This fact repeats periodically. We use it as a "heartbeat".
   (ptn (fact (mk.val light essence lights :) After: Before: ::) |[])
|[]
[]
   (inj []
      ; The end of the time interval will be used in m_drive as the end of the goal interval.
      f_run:(fact run After (+ Before 500ms) 1 1)
      |[]
   )
   (inj []
      G:(goal f_run self nil 1)
      |[]
   )
   (inj []
      ; Delay a little to allow predictions for this sampling period before injecting the drive.
      (fact G T0:(+ After 10ms) T0 1 1)
      [SYNC_ONCE T0 1 forever primary nil]
   )
   (prb [1 "print" "injected drive" |[]])
1) |[]
(ipgm pgm_inject_drive |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) []
   [SYNC_ONCE now 0 forever primary nil 1]
   
   
; TO DO: Detect goal is to connect stuff, so connect it with program
;pgm_connect:(pgm |[]
;[]
;   (ptn (fact G:(goal (fact (cmd connect [A: B:] ::) Cmd_after: Cmd_before: ::) ::) ::) |[])
;|[]
;[]
;   ; Limit DeltaP to +/- 20. Inject the fact that the command was executed.
;   (inj []
;      Command:(cmd connect [A: B:] 1)
;      |[]
;   )
;   (inj []
;      (fact Command (+ After 20ms) Before 1 1)
;      [SYNC_ONCE After 1 1 stdin nil]
;   )
;   ; Move h by DeltaP. c moves with h.
;   (inj []
;      AtoB:(fact (mk.val A: connectedto B: :) T0: T1: : :)
;	  BtoA:(fact (mk.val B: connectedto A: :) T0: T1: : :)
;      |[]
;   )
;   (inj []
;      (fact AtoB (+ After sampling_period) (+ Before sampling_period) 1 1) [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
;	  (fact BtoA (+ After sampling_period) (+ Before sampling_period) 1 1) [SYNC_PERIODIC (+ After sampling_period) 1 1 emulator nil]
;   )
;   (prb [1 "print" "pgm_connect from command:" [Command]])
;1) |[]

;(ipgm pgm_connect |[] RUN_ALWAYS MAX_TIME VOLATILE NOTIFY 1) [] [SYNC_ONCE now 0 forever emulator nil 1]